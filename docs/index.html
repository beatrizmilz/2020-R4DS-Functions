<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>index.utf8</title>
    <meta charset="utf-8" />
    <meta name="author" content="04/05/2020" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css\metropolis.css" type="text/css" />
    <link rel="stylesheet" href="css\metropolis-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css\footer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <center>
<img src= 'img/rlogos/hex-tidyverse.jpg' width = '25%' alt='Tidyverse'></br>
</center>
## Funciones <br> R para Ciencia de Datos
### 04/05/2020

---

layout: true
  
&lt;div class="my-footer"&gt;&lt;span&gt;


Source: &lt;a href="https://es.r4ds.hadley.nz/funciones.html"&gt; Funciones. R para Ciencia de Datos by Hadley Wickham and Garrett Grolemund. &lt;/a&gt; 


&lt;/span&gt;&lt;/div&gt; 
---
class:







.pull-left[

- [R for Data Science](https://r4ds.had.co.nz/)

&lt;img src="https://es.r4ds.hadley.nz/cover.png" width="70%" style="display: block; margin: auto;" /&gt;

]

.pull-right[

- [R para Ciencia de Datos](https://es.r4ds.hadley.nz/)

&lt;img src="https://es.r4ds.hadley.nz/hex_r4ds-es.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
class:

# Introducci√≥n

- Las funciones permiten automatizar algunas tareas comunes de una forma m√°s poderosa y general que copiar-y-pegar

- Consejos para:
    
    - Escribir funciones

    - Estilo de c√≥digo

## Prerrequisitos

- R

- RStudio



&lt;img src="img/rlogos/rstudio-r.jpg" width="40%" style="display: block; margin: auto;" /&gt;





---
class:

# Principio DRY - ‚ÄúDo not Repeat Yourself‚Äù

- ‚ÄúNo repetirse a uno mismo‚Äù: Cuanta m√°s repetici√≥n tengas en tu c√≥digo, m√°s lugares tendr√°s que recordar de actualizar cuando las cosas cambien, y es m√°s probable que crees errores (bugs) a lo largo del tiempo.

---
class:

# Funciones

- Extraer el c√≥digo repetido en una funci√≥n es una buena idea, ya que previene que cometas errores.

- Otra ventaja de las funcioens es que si nuestros requerimientos cambian, solo necesitamos hacer modificaciones en un solo lugar. 

- Deber√≠as considerar escribir una funci√≥n cuando has copiado y pegado un bloque de c√≥digo m√°s de dos veces.

- Para escribir una funci√≥n, lo primero que necesitas hacer es analizar el c√≥digo. ¬øCuantos inputs tiene?

-  Es m√°s f√°cil empezar con c√≥digo que funciona y luego convertirlo en una funci√≥n; es m√°s dif√≠cil crear la funci√≥n y luego tratar que funcione.


- Una funci√≥n devuelve el √∫ltimo valor que calcul√≥.


---
class:

#  Pasos claves...

## ...Para crear una funci√≥n nueva

1. Necesitas elegir un nombre para la funci√≥n.

2. Listar los inputs, o argumentos, de la funci√≥n dentro de function. 

3. Situar el c√≥digo que has creado en el cuerpo de una funci√≥n, un bloque de { que sigue inmediatamente a function(...).


```r
nome_de_la_funcion &lt;- function(argumentos){
  cuerpo de la funci√≥n
}
```


---
class:

#  Ejemplo de libro


```r
rescale01 &lt;- function(x) {
  rng &lt;- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

- `rescale01` es el nombre de la funci√≥n

- `x` es lo unico argumento

-  Cuerpo de la funci√≥n:

  `rng &lt;- range(x, na.rm = TRUE)`

  `(x - rng[1]) / (rng[2] - rng[1])`

- Ejemplo de la utilizaci√≥n de la funci√≥n:

```r
rescale01(c(0, 5, 10))
```

```
## [1] 0.0 0.5 1.0
```

---
class:

# Tests

- Es una buena idea chequear tu funci√≥n con algunos inputs diferentes:


```r
rescale01(c(-10, 0, 10))
```

```
## [1] 0.0 0.5 1.0
```

```r
rescale01(c(1, 2, 3, NA, 5))
```

```
## [1] 0.00 0.25 0.50   NA 1.00
```

- Sobre tests formales y automatizados -&gt; se llama pruebas unitarias (unit testing): leea mas en https://r-pkgs.org/tests.html

---
class:

# Las funciones son para ...

## ...los seres humanos y para las computadoras

- Consejos para estilo de c√≥digo: cosas que debes tener en mente a la hora de escribir funciones entendibles para otras personas

---
class:

# Nombre de una funci√≥n

- Deber√≠a ser corto, pero que evoque claramente lo que la funci√≥n hace.

- Generalmente, los nombres de las funciones deber√≠an ser verbos y los argumentos sustantivos, pero hay algunas excepciones.

- Ejemplos del libro:


```r
# Muy corto
f()

# No es un verbo y es poco descriptivo
mi_funcion_genial()

# Largos, pero descriptivos
imputar_faltantes()
colapsar_anios()
```


---
class:

# Case Style 

- Lo importante es que seas consistente: elije uno o el otro y qu√©date con √©l. 

- Recomendaci√≥n: `snake_case` - cada palabra en min√∫scula est√° separada por un gui√≥n bajo


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/allisonhorst/cases.jpg" alt="Source: &amp;lt;a href='https://twitter.com/allison_horst/status/1205702878544875521'&amp;gt; @allison_horst &amp;lt;/a&amp;gt;" width="60%" /&gt;
&lt;p class="caption"&gt;Source: &lt;a href='https://twitter.com/allison_horst/status/1205702878544875521'&gt; @allison_horst &lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;



---
class:

# Case Style 

- Consejo personal para tibbles

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/allisonhorst/janitor-clean-names.jpg" alt="Source: &amp;lt;a href='https://twitter.com/allison_horst/status/1170184721482932224/photo/1'&amp;gt; @allison_horst &amp;lt;/a&amp;gt;" width="40%" /&gt;
&lt;p class="caption"&gt;Source: &lt;a href='https://twitter.com/allison_horst/status/1170184721482932224/photo/1'&gt; @allison_horst &lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;


```r
names(iris)
```

```
## [1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"
```

```r
iris_clean &lt;- janitor::clean_names(iris)
names(iris_clean)
```

```
## [1] "sepal_length" "sepal_width"  "petal_length" "petal_width"  "species"
```


---
class:

# Nombres y argumentos consistentes 

- Si tienes una familia de funciones que hacen cosas similares, aseg√∫rate de que tengan nombres y argumentos consistentes.

- Utiliza un prefijo com√∫n para indicar que est√°n conectadas. Eso es mejor que usar un sufijo com√∫n, ya que el autocompletado te permite escribir el prefijo y ver todos los otros miembros de la familia.




```r
# Bien
input_select()
input_checkbox()
input_text()

# No tan bien
select_input()
checkbox_input()
text_input()
```

---
class:

#  Evita sobrescribir funciones ...

## .. ya existentes

- Siempre que sea posible, evita sobrescribir funciones y variables ya existentes. 

- No siempre es posible hacer esto, ya que hay un mont√≥n de nombres buenos que ya han sido utilizados por otros paquetes. 

- Evitar el uso de los nombres m√°s comunes de R base ahorrar√° confusiones.


```r
# ¬°No hagas esto!
T &lt;- FALSE
c &lt;- 10
mean &lt;- function(x) sum(x)
```


---
class: 

# Comentarios

- Comienzan com #

- Explicar el "porqu√©" de tu c√≥digo.

  - Por qu√© elegiste este enfoque frente a otras alternativas? 
  - ¬øQu√© otra cosa probaste que no funcion√≥?
  - Es una gran idea capturar este tipo de pensamientos en un comentario.


```r
# Esto es un comentario! :)
```

---
class: 

# Dividir el codigo en partes

- Puedes utilizar comentarios y - o =

- M√°s f√°cil detectar los fragmentos

- M√°s f√°cil de leer


```r
# Cargar los datos --------------------------------------

# Graficar los datos --------------------------------------
```


---
class: 

# Ejecuci√≥n condicional

- Una sentencia if (si) te permite ejecutar un c√≥digo condicional.


```r
if (condition) {
 # el c√≥digo que se ejecuta cuando la condici√≥n es verdadera (TRUE)
} else {
 # el c√≥digo que se ejecuta cuando la condici√≥n es falsa (FALSE)
}
```


Puedes encadenar m√∫ltiples sentencias if juntas:


```r
if (this) {
 # haz aquello
} else if (that) {
 # haz otra cosa
} else {
 #
}
```

---
class: 

# Condiciones


- La condici√≥n debe evaluar como TRUE o FALSE:


```r
if (c(TRUE, FALSE)) {}
#&gt; Warning in if (c(TRUE, FALSE)) {: the condition has length &gt; 1 and only the
#&gt; first element will be used
#&gt; NULL

if (NA) {}
#&gt; Error in if (NA) {: missing value where TRUE/FALSE needed
```


---
class: 

# Estilo del c√≥digo


```r
# Bien
if (y &lt; 0 &amp;&amp; debug) {
 message("Y es negativo")
}

if (y == 0) {
 log(x)
} else {
 y ^ x
}

# Mal
if (y &lt; 0 &amp;&amp; debug)
message("Y is negative")

if (y == 0) {
 log(x)
}
else {
 y ^ x
}
```




---
class: 

# Estilo del c√≥digo

- Atajo √∫til para indentaci√≥n: `Ctrl + Shift + A`

&lt;img src="img/gif-atalho-identacao.gif" width="100%" style="display: block; margin: auto;" /&gt;
---
class: 

# Argumentos de funciones

- 2 conjuntos amplios: 

  - Argumentos para provee los __datos__ a computar 
  
  - Argumentos que controlan los __detalles de la computaci√≥n__.
  
- Generalmente, argumentos relativos a los datos deben ir primero.

- Cuando llamas una funci√≥n, generalmente omites los nombres de los argumentos de datos justamente porque son los m√°s com√∫nmente usados. 
  
- En la secci√≥n Help de una funci√≥n, tenemos las informaciones de argumentos possibles.



---
class: 

# Argumentos de funciones

Ejemplo:


```r
?mean
```


__Arguments:__

__`x`__      __(provee los datos a computar)__
An R object. Currently there are methods for numeric/logical vectors and date, date-time and time interval objects. Complex vectors are allowed for trim = 0, only.

__`trim`__	 __(controlan los detalles de la computaci√≥n)__
the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed. Values of trim outside that range are taken as the nearest endpoint.

__`na.rm`	__  __(controlan los detalles de la computaci√≥n)__
a logical value indicating whether NA values should be stripped before the computation proceeds.

__`...`	__  __(controlan los detalles de la computaci√≥n)__
further arguments passed to or from other methods.



---
class: 

# Argumentos de funciones
## Elecci√≥n de nombres

- Los nombres de los argumentos tambi√©n son importantes.

- A R no le importa, pero s√≠ a quienes leen tu c√≥digo. 

- En general, deber√≠as preferir nombres largos y m√°s descriptivos.Pero hay un pu√±ado de nombres muy comunes y muy cortos. Vale la pena memorizar estos:

`x`, `y`, `z`: vectores.

`w`: un vector de pesos.

__`df`__: un data frame.

`i`, `j`: √≠ndices num√©ricos (usualmente filas y columnas).

`n`: longitud, o n√∫mero de filas.

`p`: n√∫mero de columnas.

---
class: 

# Argumentos de funciones

- __El orden__ de los argumentos es importante!

- Ejemplo. `mean()` tiene los argumentos: `x`, `trim`, `na.rm`. Si solo usa el primer y el tercer argumento (`x` y `na.rm`), debe nombrar el argumento para no dar un error, de lo contrario, R indicar√° este input  para el segundo argumento (en orden).


```r
mean(1:10, TRUE)


# Error in mean.default(1:10, TRUE):'trim' deve ser num√©rico de comprimento 1
```
- La mejor forma: 

```r
mean(1:10, na.rm = TRUE)
```

```
## [1] 5.5
```

---
class: 

# Argumentos de funciones

## Valores por defecto

- El valor por defecto deber√≠a ser casi siempre el valor m√°s com√∫n. 

- Se especifica un valor por defecto de la misma manera en la que se llama a una funci√≥n con un argumento nombrado.

- Ejemplo:


```r
round(5.55555)
```

```
## [1] 6
```


```r
round(5.55555, digits = 1)
```

```
## [1] 5.6
```


```r
round(5.55555, digits = 2)
```

```
## [1] 5.56
```
---
class: 

# Argumentos de funciones

## Valores por defecto

- Ejemplo del livro


```r
# Computar intervalo de confianza alrededor de la media usando
# la aproximaci√≥n normal 
mean_ci &lt;- function(x, conf = 0.95) {
 se &lt;- sd(x) / sqrt(length(x))
 alpha &lt;- 1 - conf
 mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}
```

```r
x &lt;- runif(100)
mean_ci(x)
```

```
## [1] 0.441236 0.553990
```

```r
mean_ci(x, conf = 0.99)
```

```
## [1] 0.4235211 0.5717050
```



---
class: 

# Estilo del c√≥digo


- Ten en cuenta que cuando llamas a una funci√≥n, debes colocar un espacio alrededor de = y siempre poner un espacio despu√©s de la coma, no antes (como cuando escribes en espa√±ol). 

- El uso del espacio en blanco hace m√°s f√°cil echar un vistazo a la funci√≥n para identificar los componentes importantes.


```r
# Bien
promedio &lt;- mean(pies / 12 + pulgadas, na.rm = TRUE)

# Mal
promedio&lt;-mean(pies/12+pulgadas,na.rm=TRUE)
```

- Atajo √∫til para esto: `Ctrl + Shift + A`  (de nuevo! üòÄ)

&lt;img src="img/gif-atalho-identacao.gif" width="100%" style="display: block; margin: auto;" /&gt;


---
class: 

# Argumentos de funciones

##  Chequear valores


- Chequear si los inputs utilizados son adecuadas para la funci√≥n.

- Es una buena pr√°ctica verificar las condiciones previas importantes y arrojar un error (con `stop()`, parar), si estas no son verdaderas.

- Debe haber un equilibrio entre la cantidad de tiempo que inviertes en hacer que tu funci√≥n sea s√≥lida y la cantidad de tiempo que pasas escribi√©ndola. 

---
class: 

# Argumentos de funciones

##  Chequear valores

Ejemplo:



```r
wt_mean &lt;- function(x, w) {
 if (length(x) != length(w)) {
 stop("`x` y `w` deben tener la misma extensi√≥n", call. = FALSE)
 }
 sum(w * x) / sum(w)
}
```


```r
wt_mean(1:10, 1:5)

# Erro: `x` y `w` deben tener la misma extensi√≥n
```

---
class: 

# Argumentos de funciones

##  Chequear valores

- Una opci√≥n √∫til es incorporar __`stopifnot()`__: esto comprueba que cada argumento sea TRUE. En caso contrario genera un mensaje de error. Al usar `stopifnot()` afirmas lo que deber√≠a ser cierto en lugar de verificar lo que podr√≠a estar mal.

Ejemplo:

```r
wt_mean &lt;- function(x, w, na.rm = FALSE) {
 stopifnot(is.logical(na.rm), length(na.rm) == 1)
 stopifnot(length(x) == length(w))

 if (na.rm) {
 miss &lt;- is.na(x) | is.na(w)
 x &lt;- x[!miss]
 w &lt;- w[!miss]
 }
 sum(w * x) / sum(w)
}
# wt_mean(1:6, 6:1, na.rm = "foo")
#&gt; Error in wt_mean(1:6, 6:1, na.rm = "foo"): is.logical(na.rm) is not TRUE
```


---
class: 

# Argumentos de funciones

###  Punto-punto-punto (‚Ä¶)

- `...` es un argumento especial: captura cualquier n√∫mero de argumentos que no est√©n contemplados de otra forma.

- Cualquier argumento mal escrito no generar√° un error. Esto hace que sea m√°s f√°cil que los errores de tipeo pasen inadvertidos.

Ejemplo


```r
sum(c(1, 2, NA), na.mr = TRUE)
```

```
## [1] NA
```

```r
sum(c(1, 2, NA), na.rm = TRUE)
```

```
## [1] 3
```


---
class: 

# Valores de retorno

- Cosas que debes considerar al retornar un valor:

¬øDevolver un valor antes hace que tu funci√≥n sea m√°s f√°cil de leer?

¬øPuedes hacer tu funci√≥n apta para utilizarla con pipes (`%&gt;%`)?

## Sentencias de retorno expl√≠citas

- Puedes optar por devolver algo anticipadamente haciendo uso de la funci√≥n `return()`


---
class: 

# Valores de retorno

##  Escribir funciones aptas para un pipe `%&gt;%` 

- Hay dos tipos b√°sicos de funciones aptas para pipes: transformaciones y efectos secundarios. 

- __Transformaciones__ : se ingresa un objeto como primer argumento y se retorna una versi√≥n modificada del mismo. 


```r
iris %&gt;% janitor::clean_names() 
```
  
  
- __Efectos Secundarios__ : el objeto ingresado no es modificado, sino que la funci√≥n realiza una acci√≥n sobre el objeto. -&gt; Las funciones de efectos secundarios deben retornar ‚Äúinvisiblemente‚Äù el primer argumento, de manera que a√∫n cuando no se impriman, puedan ser utilizados en una secuencia de pipes. 
  

---
class: 


Ejemplo com  __Efectos Secundarios__ :


```r
mostrar_faltantes &lt;- function(df) {
 n &lt;- sum(is.na(df))
 cat("Valores faltantes: ", n, "\n", sep = "")

 invisible(df)
}
```


```r
x &lt;- mostrar_faltantes(iris)
```

```
## Valores faltantes: 0
```

```r
class(x)
```

```
## [1] "data.frame"
```

```r
dim(x)
```

```
## [1] 150   5
```

---
class: 

# Entorno (Environment)

- Cruciales para que algunas funciones trabajen

Ejemplo:



```r
f &lt;- function(x) {
 x + y
}
```

- Como y no est√° definida dentro de la funci√≥n, R mirar√° dentro del entorno donde la funci√≥n fue definida


```r
y &lt;- 100
f(10)
```

```
## [1] 110
```

```r
y &lt;- 1000
f(10)
```

```
## [1] 1010
```


---
class:

- Muchas gracias!

- Diapositivas creadas con el paquete [Xaringan](https://github.com/yihui/xaringan), con el tema `metropolis` modificado por [Bea Milz](https://beatrizmilz.com).

- Source: &lt;a href="https://es.r4ds.hadley.nz/funciones.html"&gt; Funciones. R para Ciencia de Datos by Hadley Wickham and Garrett Grolemund. &lt;/a&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<style>
  .logo {
    background-image: url(img/rlogos/hex-tidyverse.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 0.5em;
    right: 0.5em;
    width: 50px;
    height: 128px;
    z-index: 0;
  }
</style>
  
  <script>
  document
.querySelectorAll(
  '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
  // ':not(.inverse)' +
    ':not(.hide-logo)'
)
.forEach(el => {
  el.innerHTML += '<div class="logo"></div>';
});
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
